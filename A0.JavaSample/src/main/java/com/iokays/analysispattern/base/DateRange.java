package com.iokays.analysispattern.base;

/*Generated by MPS*/

import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Arrays;
import java.util.Date;

public class DateRange implements Comparable {
    public static DateRange EMPTY = new DateRange(LocalDate.of(2000, 4, 1), LocalDate.of(2000, 1, 1));
    private final LocalDate myStart;
    private final LocalDate myEnd;

    public DateRange(Date start, Date end) {
        this(convertToLocalDateViaInstant(start), convertToLocalDateViaInstant(end));
    }

    public DateRange(LocalDate start, LocalDate end) {
        this.myStart = start;
        this.myEnd = end;
    }

    public LocalDate end() {
        return myEnd;
    }

    public LocalDate start() {
        return myStart;
    }

    @Override
    public String toString() {
        if (isEmpty()) {
            return "Empty Date Range";
        }
        return myStart.toString() + " - " + myEnd.toString();
    }

    public boolean isEmpty() {
        return myStart.isAfter(myEnd);
    }

    public boolean includes(LocalDate arg) {
        return !(arg.isBefore(myStart)) && !(arg.isAfter(myEnd));
    }

    @Override
    public boolean equals(Object arg) {
        if (!(arg instanceof DateRange)) {
            return false;
        }
        DateRange other = (DateRange) arg;
        return myStart.equals(other.myStart) && myEnd.equals(other.myEnd);
    }

    @Override
    public int hashCode() {
        return myStart.hashCode();
    }

    public boolean overlaps(DateRange arg) {
        return arg.includes(myStart) || arg.includes(myEnd) || this.includes(arg);
    }

    public boolean includes(DateRange arg) {
        return this.includes(arg.myStart) && this.includes(arg.myEnd);
    }

    public DateRange gap(DateRange arg) {
        if (this.overlaps(arg)) {
            return EMPTY;
        }
        DateRange lower;
        DateRange higher;
        if (this.compareTo(arg) < 0) {
            lower = this;
            higher = arg;
        } else {
            lower = arg;
            higher = this;
        }
        return new DateRange(lower.myEnd.plusDays(1), higher.myStart.plusDays(-1));
    }

    @Override
    public int compareTo(Object arg) {
        DateRange other = (DateRange) arg;
        if (!(myStart.equals(other.myStart))) {
            return myStart.compareTo(other.myStart);
        }
        return myEnd.compareTo(other.myEnd);
    }

    public boolean abuts(DateRange arg) {
        return !(this.overlaps(arg)) && this.gap(arg).isEmpty();
    }

    public boolean partitionedBy(DateRange[] args) {
        if (!(DateRange.isContiguous(args))) {
            return false;
        }
        return this.equals(DateRange.combination(args));
    }

    public static DateRange upTo(LocalDate end) {
        return new DateRange(LocalDate.MIN, end);
    }

    public static DateRange startingOn(LocalDate start) {
        return new DateRange(start, LocalDate.MAX);
    }

    public static DateRange combination(DateRange[] args) {
        Arrays.sort(args);
        if (!(DateRange.isContiguous(args))) {
            throw new IllegalArgumentException("Unable to combine date ranges");
        }
        return new DateRange(args[0].myStart, args[args.length - 1].myEnd);
    }

    public static boolean isContiguous(DateRange[] args) {
        Arrays.sort(args);
        for (int i = 0; i < args.length - 1; i++) {
            if (!(args[i].abuts(args[i + 1]))) {
                return false;
            }
        }
        return true;
    }

    public static LocalDate convertToLocalDateViaInstant(Date dateToConvert) {
        return dateToConvert.toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDate();
    }

}